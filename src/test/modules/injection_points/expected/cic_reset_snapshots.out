CREATE EXTENSION injection_points;
SELECT injection_points_set_local();
 injection_points_set_local 
----------------------------
 
(1 row)

SELECT injection_points_attach('heap_reset_scan_snapshot_effective', 'notice');
 injection_points_attach 
-------------------------
 
(1 row)

SELECT injection_points_attach('table_beginscan_strat_reset_snapshots', 'notice');
 injection_points_attach 
-------------------------
 
(1 row)

SELECT injection_points_attach('table_parallelscan_initialize', 'notice');
 injection_points_attach 
-------------------------
 
(1 row)

CREATE SCHEMA cic_reset_snap;
CREATE TABLE cic_reset_snap.tbl(i int primary key, j int);
INSERT INTO cic_reset_snap.tbl SELECT i, i * I FROM generate_series(1, 200) s(i);
CREATE FUNCTION cic_reset_snap.predicate_stable(integer) RETURNS bool IMMUTABLE
									  LANGUAGE plpgsql AS $$
BEGIN
    EXECUTE 'SELECT txid_current()';
    RETURN MOD($1, 2) = 0;
END; $$;
CREATE FUNCTION cic_reset_snap.predicate_stable_no_param() RETURNS bool IMMUTABLE
									  LANGUAGE plpgsql AS $$
BEGIN
    EXECUTE 'SELECT txid_current()';
    RETURN false;
END; $$;
----------------
ALTER TABLE cic_reset_snap.tbl SET (parallel_workers=0);
CREATE UNIQUE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i);
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i);
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(MOD(i, 2), j) WHERE MOD(i, 2) = 0;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i, j) WHERE cic_reset_snap.predicate_stable(i);
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i, j) WHERE cic_reset_snap.predicate_stable_no_param();
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl USING BRIN(i);
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
NOTICE:  notice triggered for injection point heap_reset_scan_snapshot_effective
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
-- The same in parallel mode
ALTER TABLE cic_reset_snap.tbl SET (parallel_workers=2);
-- Detach to keep test stable, since parallel worker may complete scan before leader
SELECT injection_points_detach('heap_reset_scan_snapshot_effective');
 injection_points_detach 
-------------------------
 
(1 row)

CREATE UNIQUE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i);
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i);
NOTICE:  notice triggered for injection point table_parallelscan_initialize
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_parallelscan_initialize
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(MOD(i, 2), j) WHERE MOD(i, 2) = 0;
NOTICE:  notice triggered for injection point table_parallelscan_initialize
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_parallelscan_initialize
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i, j) WHERE cic_reset_snap.predicate_stable(i);
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_beginscan_strat_reset_snapshots
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl(i, j) WHERE cic_reset_snap.predicate_stable_no_param();
NOTICE:  notice triggered for injection point table_parallelscan_initialize
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_parallelscan_initialize
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
CREATE INDEX CONCURRENTLY idx ON cic_reset_snap.tbl USING BRIN(i);
NOTICE:  notice triggered for injection point table_parallelscan_initialize
REINDEX INDEX CONCURRENTLY cic_reset_snap.idx;
NOTICE:  notice triggered for injection point table_parallelscan_initialize
DROP INDEX CONCURRENTLY cic_reset_snap.idx;
DROP SCHEMA cic_reset_snap CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table cic_reset_snap.tbl
drop cascades to function cic_reset_snap.predicate_stable(integer)
drop cascades to function cic_reset_snap.predicate_stable_no_param()
DROP EXTENSION injection_points;
